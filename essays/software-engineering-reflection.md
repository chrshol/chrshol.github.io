---
layout: essay
type: essay
title: "Learning Real-World Software Engineering"
# All dates must be YYYY-MM-DD format!
date: 2024-12-16
published: true
labels:
  - Software Engineering
  - Reflection
  - Coding Standards
  - Agile Project Management
  - Configuration Management
---


Throughout this semester in my software engineering course, I've discovered that there's so much more to the field than just developing web applications. I now have a genuine understanding of what it means to work in large-scale software development teams in the real world. Three fundamental concepts have particularly transformed my perspective on software engineering: Coding Standards, Agile Project Management, and Configuration Management. While I learned these in the context of web development, their applications extend far beyond that, influencing how we tackle any complex technological project.

<div style="text-align: start;">
  <img width="70%" class="rounded" src="../img/ai-learning/AI-learning.jpg" alt="City Planning Picture">
</div>

<br>

### Coding Standards  
At first glance, coding standards might seem like just a bunch of rigid rules about where to put brackets or how to name variables. But my experience with implementing ESLint in TypeScript projects (which, I'll admit, was pretty frustrating at first!) taught me that these standards serve a crucial purpose. They're essentially a communication tool that enables developers to speak the same "language" even when working independently.

I've found myself drawing parallels between coding standards and learning grammar in my German class this semester. Just as I struggle with German grammar rules, those stubborn ESLint errors were initially challenging because my code wasn't "grammatically correct." But just as proper grammar helps readers understand written text, coding standards help developers understand each other's code. When everyone follows the same conventions, code reviews become smoother, maintenance gets easier, and the overall quality of the software improves significantly.


### Agile Project Management  
My real "aha moment" came when working with my group on the final project. That's when I truly grasped what goes into building software collaboratively. We implemented Issue-Driven Project Management, and it just clicked – it felt incredibly efficient and logical! At its core, Agile is about breaking down intimidating projects into manageable pieces while maintaining flexibility throughout the development process.
As someone who loves structure and organizing (yes, I'm a bit of a control freak!), GitHub's issue tracking system was a game-changer for me. It provided everything I wanted: clarity, ease of use, progress tracking, and a perfect way to assign responsibilities. It ensured everyone had clear tasks and knew exactly what they needed to do.

What's really cool is how this approach works beyond software development. For instance, in another class this semester, I was part of a team building a startup from scratch. Looking back, I realize how beneficial Issue-Driven Project Management would have been for that project. When you're trying to build a startup, the workload can seem overwhelming, but breaking it into smaller milestones makes it more approachable. Since team members were working on different aspects of the startup, using issues would have given everyone better visibility into each other's work and likely made our communication much smoother.



### Configuration Management
The most exciting revelation for me was Configuration Management, particularly mastering Git and GitHub. I'll be honest – before this course, Git terrified me! My first experience with it led to countless conflicts because my teammate and I weren't using it correctly. After that traumatic experience, I tried to avoid it completely. But now? It's become second nature, and I'm amazed at how effortless version control has become.
Configuration Management is essentially about maintaining order in chaos. Through Git commands, I learned to create branches for new features, merge changes confidently, and maintain a clear history of project development. It's not just about storing different versions; it's about enabling collaboration while maintaining stability. The ability to experiment in separate branches while keeping the main project stable is invaluable in any context where multiple people work on complex, evolving deliverables.



### Conclusion  
These experiences have shown me that software engineering transcends just writing code and building web applications – it's about managing complexity, enabling collaboration, and maintaining quality over time. Whether I'm developing a web application, creating a startup business proposal, or organizing a social event for my study program, these principles provide a solid framework for achieving success through systematic, collaborative effort.

The tools and practices I've learned – from ESLint to Git, from issue tracking to milestone planning – are specific implementations of broader principles. They've given me practical experience in managing complex projects and working effectively in teams. As I move forward in my career, I'm confident these lessons will prove valuable far beyond the realm of web development.



